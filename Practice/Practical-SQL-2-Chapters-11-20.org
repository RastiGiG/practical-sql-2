#+TITLE: Practical SQL 2 - Practice Chapters 1-10
#+AUTHOR: Sebastian Zierl
#+DATE:  [2022-02-10] 

:PROPERTIES:

* Practical SQL 2 - Exercises Chapters 11-20
** Chapter 11 - Statistical Functions in SQL
*** 
*** PRACTICE
**** Setup
Here we create the tables required for this exercise:
#+NAME: chapter-10-P0
#+HEADER: :engine postgres
#+HEADER: :dbhost localhost
#+HEADER: :dbuser sebastian
#+HEADER: :database analysis
#+begin_src sql
  CREATE TABLE albums (
      album_id bigint GENERATED ALWAYS AS IDENTITY,
      catalog_code text,
      title text,
      artist text,
      release_date date,
      genre text,
      description text
  );

  CREATE TABLE songs (
      song_id bigint GENERATED ALWAYS AS IDENTITY,
      title text,
      composers text,
      album_id bigint
  );  
#+end_src
**** A
+ Question:
  Modify these CREATE TABLE statements to include primary and foreign keys plus additional constraints on both tables.
  Explain why you made your choices.
+ Answer:
  * Both tables get a primary key using surrogate key id values that are auto-generated via IDENTITY.
  * The songs table references albums via a foreign key constraint.
  * In both tables, the title and artist/composer columns cannot be empty, which is specified via a NOT NULL constraint.
    We assume that every album and song should at minimum have that information.
  * In albums, the release_date column has a CHECK constraint because it would be likely impossible for us to own an LP made before 1925.
#+NAME: chapter-10-P1
#+HEADER: :engine postgres
#+HEADER: :dbhost localhost
#+HEADER: :dbuser sebastian
#+HEADER: :database analysis
#+begin_src sql
  CREATE TABLE albums (
      album_id bigint GENERATED ALWAYS AS IDENTITY,
      catalog_code text NOT NULL,
      title text NOT NULL,
      artist text NOT NULL,
      release_date date,
      genre text,
      description text,
      CONSTRAINT album_id_key PRIMARY KEY (album_id),
      CONSTRAINT release_date_check CHECK (release_date > '1/1/1925')
  );

  CREATE TABLE songs (
      song_id bigint GENERATED ALWAYS AS IDENTITY,
      title text NOT NULL,
      composers text NOT NULL,
      album_id bigint REFERENCES albums (album_id)
      CONSTRAINT song_id_key PRIMARY KEY (song_id)
  );  
#+end_src
**** B
+ Question:
  Instead of using =album_id= as a surrogate key for your ~primary key~, are there any columns in albums that could be useful as a natural key?
  What would you have to know to decide?
+ Answer:
  We could consider the catalog_code. We would have to answer yes to these questions:
  1. Is it going to be unique across all albums released by all companies?
  2. Will an album always have a catelog code?
**** C
+ Question:
  To speed up queries, which columns are good candidates for indexes?
+ Answer:
  Primary key columns get indexes by default, but we should add an index to the album_id foreign key column in the songs table because we'll use it in table joins.
  It's likely that we'll query these tables to search by titles and artists, so those columns in both tables should get indexes too.
  The release_date in albums also is a candidate if we expect to perform many queries that include date ranges.
** Chapter 12 -
*** 
*** PRACTICE
**** Setup
Here we create the tables required for this exercise:
#+NAME: chapter-8-P0
#+HEADER: :engine postgres
#+HEADER: :dbhost localhost
#+HEADER: :dbuser sebastian
#+HEADER: :database analysis
#+begin_src sql
  CREATE TABLE albums (
      album_id bigint GENERATED ALWAYS AS IDENTITY,
      catalog_code text,
      title text,
      artist text,
      release_date date,
      genre text,
      description text
  );

  CREATE TABLE songs (
      song_id bigint GENERATED ALWAYS AS IDENTITY,
      title text,
      composers text,
      album_id bigint
  );  
#+end_src
**** A
+ Question:
  Modify these CREATE TABLE statements to include primary and foreign keys plus additional constraints on both tables.
  Explain why you made your choices.
+ Answer:
  * Both tables get a primary key using surrogate key id values that are auto-generated via IDENTITY.
  * The songs table references albums via a foreign key constraint.
  * In both tables, the title and artist/composer columns cannot be empty, which is specified via a NOT NULL constraint.
    We assume that every album and song should at minimum have that information.
  * In albums, the release_date column has a CHECK constraint because it would be likely impossible for us to own an LP made before 1925.
#+NAME: chapter-8-P1
#+HEADER: :engine postgres
#+HEADER: :dbhost localhost
#+HEADER: :dbuser sebastian
#+HEADER: :database analysis
#+begin_src sql
  CREATE TABLE albums (
      album_id bigint GENERATED ALWAYS AS IDENTITY,
      catalog_code text NOT NULL,
      title text NOT NULL,
      artist text NOT NULL,
      release_date date,
      genre text,
      description text,
      CONSTRAINT album_id_key PRIMARY KEY (album_id),
      CONSTRAINT release_date_check CHECK (release_date > '1/1/1925')
  );

  CREATE TABLE songs (
      song_id bigint GENERATED ALWAYS AS IDENTITY,
      title text NOT NULL,
      composers text NOT NULL,
      album_id bigint REFERENCES albums (album_id)
      CONSTRAINT song_id_key PRIMARY KEY (song_id)
  );  
#+end_src
**** B
+ Question:
  Instead of using =album_id= as a surrogate key for your ~primary key~, are there any columns in albums that could be useful as a natural key?
  What would you have to know to decide?
+ Answer:
  We could consider the catalog_code. We would have to answer yes to these questions:
  1. Is it going to be unique across all albums released by all companies?
  2. Will an album always have a catelog code?
**** C
+ Question:
  To speed up queries, which columns are good candidates for indexes?
+ Answer:
  Primary key columns get indexes by default, but we should add an index to the album_id foreign key column in the songs table because we'll use it in table joins.
  It's likely that we'll query these tables to search by titles and artists, so those columns in both tables should get indexes too.
  The release_date in albums also is a candidate if we expect to perform many queries that include date ranges.
** Chapter 13 -
*** 
*** PRACTICE
**** Setup
Here we create the tables required for this exercise:
#+NAME: chapter-8-P0
#+HEADER: :engine postgres
#+HEADER: :dbhost localhost
#+HEADER: :dbuser sebastian
#+HEADER: :database analysis
#+begin_src sql
  CREATE TABLE albums (
      album_id bigint GENERATED ALWAYS AS IDENTITY,
      catalog_code text,
      title text,
      artist text,
      release_date date,
      genre text,
      description text
  );

  CREATE TABLE songs (
      song_id bigint GENERATED ALWAYS AS IDENTITY,
      title text,
      composers text,
      album_id bigint
  );  
#+end_src
**** A
+ Question:
  Modify these CREATE TABLE statements to include primary and foreign keys plus additional constraints on both tables.
  Explain why you made your choices.
+ Answer:
  * Both tables get a primary key using surrogate key id values that are auto-generated via IDENTITY.
  * The songs table references albums via a foreign key constraint.
  * In both tables, the title and artist/composer columns cannot be empty, which is specified via a NOT NULL constraint.
    We assume that every album and song should at minimum have that information.
  * In albums, the release_date column has a CHECK constraint because it would be likely impossible for us to own an LP made before 1925.
#+NAME: chapter-8-P1
#+HEADER: :engine postgres
#+HEADER: :dbhost localhost
#+HEADER: :dbuser sebastian
#+HEADER: :database analysis
#+begin_src sql
  CREATE TABLE albums (
      album_id bigint GENERATED ALWAYS AS IDENTITY,
      catalog_code text NOT NULL,
      title text NOT NULL,
      artist text NOT NULL,
      release_date date,
      genre text,
      description text,
      CONSTRAINT album_id_key PRIMARY KEY (album_id),
      CONSTRAINT release_date_check CHECK (release_date > '1/1/1925')
  );

  CREATE TABLE songs (
      song_id bigint GENERATED ALWAYS AS IDENTITY,
      title text NOT NULL,
      composers text NOT NULL,
      album_id bigint REFERENCES albums (album_id)
      CONSTRAINT song_id_key PRIMARY KEY (song_id)
  );  
#+end_src
**** B
+ Question:
  Instead of using =album_id= as a surrogate key for your ~primary key~, are there any columns in albums that could be useful as a natural key?
  What would you have to know to decide?
+ Answer:
  We could consider the catalog_code. We would have to answer yes to these questions:
  1. Is it going to be unique across all albums released by all companies?
  2. Will an album always have a catelog code?
**** C
+ Question:
  To speed up queries, which columns are good candidates for indexes?
+ Answer:
  Primary key columns get indexes by default, but we should add an index to the album_id foreign key column in the songs table because we'll use it in table joins.
  It's likely that we'll query these tables to search by titles and artists, so those columns in both tables should get indexes too.
  The release_date in albums also is a candidate if we expect to perform many queries that include date ranges.
** Chapter 14 -
*** 
*** PRACTICE
**** Setup
Here we create the tables required for this exercise:
#+NAME: chapter-8-P0
#+HEADER: :engine postgres
#+HEADER: :dbhost localhost
#+HEADER: :dbuser sebastian
#+HEADER: :database analysis
#+begin_src sql
  CREATE TABLE albums (
      album_id bigint GENERATED ALWAYS AS IDENTITY,
      catalog_code text,
      title text,
      artist text,
      release_date date,
      genre text,
      description text
  );

  CREATE TABLE songs (
      song_id bigint GENERATED ALWAYS AS IDENTITY,
      title text,
      composers text,
      album_id bigint
  );  
#+end_src
**** A
+ Question:
  Modify these CREATE TABLE statements to include primary and foreign keys plus additional constraints on both tables.
  Explain why you made your choices.
+ Answer:
  * Both tables get a primary key using surrogate key id values that are auto-generated via IDENTITY.
  * The songs table references albums via a foreign key constraint.
  * In both tables, the title and artist/composer columns cannot be empty, which is specified via a NOT NULL constraint.
    We assume that every album and song should at minimum have that information.
  * In albums, the release_date column has a CHECK constraint because it would be likely impossible for us to own an LP made before 1925.
#+NAME: chapter-8-P1
#+HEADER: :engine postgres
#+HEADER: :dbhost localhost
#+HEADER: :dbuser sebastian
#+HEADER: :database analysis
#+begin_src sql
  CREATE TABLE albums (
      album_id bigint GENERATED ALWAYS AS IDENTITY,
      catalog_code text NOT NULL,
      title text NOT NULL,
      artist text NOT NULL,
      release_date date,
      genre text,
      description text,
      CONSTRAINT album_id_key PRIMARY KEY (album_id),
      CONSTRAINT release_date_check CHECK (release_date > '1/1/1925')
  );

  CREATE TABLE songs (
      song_id bigint GENERATED ALWAYS AS IDENTITY,
      title text NOT NULL,
      composers text NOT NULL,
      album_id bigint REFERENCES albums (album_id)
      CONSTRAINT song_id_key PRIMARY KEY (song_id)
  );  
#+end_src
**** B
+ Question:
  Instead of using =album_id= as a surrogate key for your ~primary key~, are there any columns in albums that could be useful as a natural key?
  What would you have to know to decide?
+ Answer:
  We could consider the catalog_code. We would have to answer yes to these questions:
  1. Is it going to be unique across all albums released by all companies?
  2. Will an album always have a catelog code?
**** C
+ Question:
  To speed up queries, which columns are good candidates for indexes?
+ Answer:
  Primary key columns get indexes by default, but we should add an index to the album_id foreign key column in the songs table because we'll use it in table joins.
  It's likely that we'll query these tables to search by titles and artists, so those columns in both tables should get indexes too.
  The release_date in albums also is a candidate if we expect to perform many queries that include date ranges.
** Chapter 15 -
*** 
*** PRACTICE
**** Setup
Here we create the tables required for this exercise:
#+NAME: chapter-8-P0
#+HEADER: :engine postgres
#+HEADER: :dbhost localhost
#+HEADER: :dbuser sebastian
#+HEADER: :database analysis
#+begin_src sql
  CREATE TABLE albums (
      album_id bigint GENERATED ALWAYS AS IDENTITY,
      catalog_code text,
      title text,
      artist text,
      release_date date,
      genre text,
      description text
  );

  CREATE TABLE songs (
      song_id bigint GENERATED ALWAYS AS IDENTITY,
      title text,
      composers text,
      album_id bigint
  );  
#+end_src
**** A
+ Question:
  Modify these CREATE TABLE statements to include primary and foreign keys plus additional constraints on both tables.
  Explain why you made your choices.
+ Answer:
  * Both tables get a primary key using surrogate key id values that are auto-generated via IDENTITY.
  * The songs table references albums via a foreign key constraint.
  * In both tables, the title and artist/composer columns cannot be empty, which is specified via a NOT NULL constraint.
    We assume that every album and song should at minimum have that information.
  * In albums, the release_date column has a CHECK constraint because it would be likely impossible for us to own an LP made before 1925.
#+NAME: chapter-8-P1
#+HEADER: :engine postgres
#+HEADER: :dbhost localhost
#+HEADER: :dbuser sebastian
#+HEADER: :database analysis
#+begin_src sql
  CREATE TABLE albums (
      album_id bigint GENERATED ALWAYS AS IDENTITY,
      catalog_code text NOT NULL,
      title text NOT NULL,
      artist text NOT NULL,
      release_date date,
      genre text,
      description text,
      CONSTRAINT album_id_key PRIMARY KEY (album_id),
      CONSTRAINT release_date_check CHECK (release_date > '1/1/1925')
  );

  CREATE TABLE songs (
      song_id bigint GENERATED ALWAYS AS IDENTITY,
      title text NOT NULL,
      composers text NOT NULL,
      album_id bigint REFERENCES albums (album_id)
      CONSTRAINT song_id_key PRIMARY KEY (song_id)
  );  
#+end_src
**** B
+ Question:
  Instead of using =album_id= as a surrogate key for your ~primary key~, are there any columns in albums that could be useful as a natural key?
  What would you have to know to decide?
+ Answer:
  We could consider the catalog_code. We would have to answer yes to these questions:
  1. Is it going to be unique across all albums released by all companies?
  2. Will an album always have a catelog code?
**** C
+ Question:
  To speed up queries, which columns are good candidates for indexes?
+ Answer:
  Primary key columns get indexes by default, but we should add an index to the album_id foreign key column in the songs table because we'll use it in table joins.
  It's likely that we'll query these tables to search by titles and artists, so those columns in both tables should get indexes too.
  The release_date in albums also is a candidate if we expect to perform many queries that include date ranges.
** Chapter 16 -
*** 
*** PRACTICE
**** Setup
Here we create the tables required for this exercise:
#+NAME: chapter-8-P0
#+HEADER: :engine postgres
#+HEADER: :dbhost localhost
#+HEADER: :dbuser sebastian
#+HEADER: :database analysis
#+begin_src sql
  CREATE TABLE albums (
      album_id bigint GENERATED ALWAYS AS IDENTITY,
      catalog_code text,
      title text,
      artist text,
      release_date date,
      genre text,
      description text
  );

  CREATE TABLE songs (
      song_id bigint GENERATED ALWAYS AS IDENTITY,
      title text,
      composers text,
      album_id bigint
  );  
#+end_src
**** A
+ Question:
  Modify these CREATE TABLE statements to include primary and foreign keys plus additional constraints on both tables.
  Explain why you made your choices.
+ Answer:
  * Both tables get a primary key using surrogate key id values that are auto-generated via IDENTITY.
  * The songs table references albums via a foreign key constraint.
  * In both tables, the title and artist/composer columns cannot be empty, which is specified via a NOT NULL constraint.
    We assume that every album and song should at minimum have that information.
  * In albums, the release_date column has a CHECK constraint because it would be likely impossible for us to own an LP made before 1925.
#+NAME: chapter-8-P1
#+HEADER: :engine postgres
#+HEADER: :dbhost localhost
#+HEADER: :dbuser sebastian
#+HEADER: :database analysis
#+begin_src sql
  CREATE TABLE albums (
      album_id bigint GENERATED ALWAYS AS IDENTITY,
      catalog_code text NOT NULL,
      title text NOT NULL,
      artist text NOT NULL,
      release_date date,
      genre text,
      description text,
      CONSTRAINT album_id_key PRIMARY KEY (album_id),
      CONSTRAINT release_date_check CHECK (release_date > '1/1/1925')
  );

  CREATE TABLE songs (
      song_id bigint GENERATED ALWAYS AS IDENTITY,
      title text NOT NULL,
      composers text NOT NULL,
      album_id bigint REFERENCES albums (album_id)
      CONSTRAINT song_id_key PRIMARY KEY (song_id)
  );  
#+end_src
**** B
+ Question:
  Instead of using =album_id= as a surrogate key for your ~primary key~, are there any columns in albums that could be useful as a natural key?
  What would you have to know to decide?
+ Answer:
  We could consider the catalog_code. We would have to answer yes to these questions:
  1. Is it going to be unique across all albums released by all companies?
  2. Will an album always have a catelog code?
**** C
+ Question:
  To speed up queries, which columns are good candidates for indexes?
+ Answer:
  Primary key columns get indexes by default, but we should add an index to the album_id foreign key column in the songs table because we'll use it in table joins.
  It's likely that we'll query these tables to search by titles and artists, so those columns in both tables should get indexes too.
  The release_date in albums also is a candidate if we expect to perform many queries that include date ranges.
** Chapter 17 -
*** 
*** PRACTICE
**** Setup
Here we create the tables required for this exercise:
#+NAME: chapter-8-P0
#+HEADER: :engine postgres
#+HEADER: :dbhost localhost
#+HEADER: :dbuser sebastian
#+HEADER: :database analysis
#+begin_src sql
  CREATE TABLE albums (
      album_id bigint GENERATED ALWAYS AS IDENTITY,
      catalog_code text,
      title text,
      artist text,
      release_date date,
      genre text,
      description text
  );

  CREATE TABLE songs (
      song_id bigint GENERATED ALWAYS AS IDENTITY,
      title text,
      composers text,
      album_id bigint
  );  
#+end_src
**** A
+ Question:
  Modify these CREATE TABLE statements to include primary and foreign keys plus additional constraints on both tables.
  Explain why you made your choices.
+ Answer:
  * Both tables get a primary key using surrogate key id values that are auto-generated via IDENTITY.
  * The songs table references albums via a foreign key constraint.
  * In both tables, the title and artist/composer columns cannot be empty, which is specified via a NOT NULL constraint.
    We assume that every album and song should at minimum have that information.
  * In albums, the release_date column has a CHECK constraint because it would be likely impossible for us to own an LP made before 1925.
#+NAME: chapter-8-P1
#+HEADER: :engine postgres
#+HEADER: :dbhost localhost
#+HEADER: :dbuser sebastian
#+HEADER: :database analysis
#+begin_src sql
  CREATE TABLE albums (
      album_id bigint GENERATED ALWAYS AS IDENTITY,
      catalog_code text NOT NULL,
      title text NOT NULL,
      artist text NOT NULL,
      release_date date,
      genre text,
      description text,
      CONSTRAINT album_id_key PRIMARY KEY (album_id),
      CONSTRAINT release_date_check CHECK (release_date > '1/1/1925')
  );

  CREATE TABLE songs (
      song_id bigint GENERATED ALWAYS AS IDENTITY,
      title text NOT NULL,
      composers text NOT NULL,
      album_id bigint REFERENCES albums (album_id)
      CONSTRAINT song_id_key PRIMARY KEY (song_id)
  );  
#+end_src
**** B
+ Question:
  Instead of using =album_id= as a surrogate key for your ~primary key~, are there any columns in albums that could be useful as a natural key?
  What would you have to know to decide?
+ Answer:
  We could consider the catalog_code. We would have to answer yes to these questions:
  1. Is it going to be unique across all albums released by all companies?
  2. Will an album always have a catelog code?
**** C
+ Question:
  To speed up queries, which columns are good candidates for indexes?
+ Answer:
  Primary key columns get indexes by default, but we should add an index to the album_id foreign key column in the songs table because we'll use it in table joins.
  It's likely that we'll query these tables to search by titles and artists, so those columns in both tables should get indexes too.
  The release_date in albums also is a candidate if we expect to perform many queries that include date ranges.
** Chapter 18 -
*** 
*** PRACTICE
**** Setup
Here we create the tables required for this exercise:
#+NAME: chapter-8-P0
#+HEADER: :engine postgres
#+HEADER: :dbhost localhost
#+HEADER: :dbuser sebastian
#+HEADER: :database analysis
#+begin_src sql
  CREATE TABLE albums (
      album_id bigint GENERATED ALWAYS AS IDENTITY,
      catalog_code text,
      title text,
      artist text,
      release_date date,
      genre text,
      description text
  );

  CREATE TABLE songs (
      song_id bigint GENERATED ALWAYS AS IDENTITY,
      title text,
      composers text,
      album_id bigint
  );  
#+end_src
**** A
+ Question:
  Modify these CREATE TABLE statements to include primary and foreign keys plus additional constraints on both tables.
  Explain why you made your choices.
+ Answer:
  * Both tables get a primary key using surrogate key id values that are auto-generated via IDENTITY.
  * The songs table references albums via a foreign key constraint.
  * In both tables, the title and artist/composer columns cannot be empty, which is specified via a NOT NULL constraint.
    We assume that every album and song should at minimum have that information.
  * In albums, the release_date column has a CHECK constraint because it would be likely impossible for us to own an LP made before 1925.
#+NAME: chapter-8-P1
#+HEADER: :engine postgres
#+HEADER: :dbhost localhost
#+HEADER: :dbuser sebastian
#+HEADER: :database analysis
#+begin_src sql
  CREATE TABLE albums (
      album_id bigint GENERATED ALWAYS AS IDENTITY,
      catalog_code text NOT NULL,
      title text NOT NULL,
      artist text NOT NULL,
      release_date date,
      genre text,
      description text,
      CONSTRAINT album_id_key PRIMARY KEY (album_id),
      CONSTRAINT release_date_check CHECK (release_date > '1/1/1925')
  );

  CREATE TABLE songs (
      song_id bigint GENERATED ALWAYS AS IDENTITY,
      title text NOT NULL,
      composers text NOT NULL,
      album_id bigint REFERENCES albums (album_id)
      CONSTRAINT song_id_key PRIMARY KEY (song_id)
  );  
#+end_src
**** B
+ Question:
  Instead of using =album_id= as a surrogate key for your ~primary key~, are there any columns in albums that could be useful as a natural key?
  What would you have to know to decide?
+ Answer:
  We could consider the catalog_code. We would have to answer yes to these questions:
  1. Is it going to be unique across all albums released by all companies?
  2. Will an album always have a catelog code?
**** C
+ Question:
  To speed up queries, which columns are good candidates for indexes?
+ Answer:
  Primary key columns get indexes by default, but we should add an index to the album_id foreign key column in the songs table because we'll use it in table joins.
  It's likely that we'll query these tables to search by titles and artists, so those columns in both tables should get indexes too.
  The release_date in albums also is a candidate if we expect to perform many queries that include date ranges.
** Chapter 19 -
*** 
*** PRACTICE
**** Setup
Here we create the tables required for this exercise:
#+NAME: chapter-8-P0
#+HEADER: :engine postgres
#+HEADER: :dbhost localhost
#+HEADER: :dbuser sebastian
#+HEADER: :database analysis
#+begin_src sql
  CREATE TABLE albums (
      album_id bigint GENERATED ALWAYS AS IDENTITY,
      catalog_code text,
      title text,
      artist text,
      release_date date,
      genre text,
      description text
  );

  CREATE TABLE songs (
      song_id bigint GENERATED ALWAYS AS IDENTITY,
      title text,
      composers text,
      album_id bigint
  );  
#+end_src
**** A
+ Question:
  Modify these CREATE TABLE statements to include primary and foreign keys plus additional constraints on both tables.
  Explain why you made your choices.
+ Answer:
  * Both tables get a primary key using surrogate key id values that are auto-generated via IDENTITY.
  * The songs table references albums via a foreign key constraint.
  * In both tables, the title and artist/composer columns cannot be empty, which is specified via a NOT NULL constraint.
    We assume that every album and song should at minimum have that information.
  * In albums, the release_date column has a CHECK constraint because it would be likely impossible for us to own an LP made before 1925.
#+NAME: chapter-8-P1
#+HEADER: :engine postgres
#+HEADER: :dbhost localhost
#+HEADER: :dbuser sebastian
#+HEADER: :database analysis
#+begin_src sql
  CREATE TABLE albums (
      album_id bigint GENERATED ALWAYS AS IDENTITY,
      catalog_code text NOT NULL,
      title text NOT NULL,
      artist text NOT NULL,
      release_date date,
      genre text,
      description text,
      CONSTRAINT album_id_key PRIMARY KEY (album_id),
      CONSTRAINT release_date_check CHECK (release_date > '1/1/1925')
  );

  CREATE TABLE songs (
      song_id bigint GENERATED ALWAYS AS IDENTITY,
      title text NOT NULL,
      composers text NOT NULL,
      album_id bigint REFERENCES albums (album_id)
      CONSTRAINT song_id_key PRIMARY KEY (song_id)
  );  
#+end_src
**** B
+ Question:
  Instead of using =album_id= as a surrogate key for your ~primary key~, are there any columns in albums that could be useful as a natural key?
  What would you have to know to decide?
+ Answer:
  We could consider the catalog_code. We would have to answer yes to these questions:
  1. Is it going to be unique across all albums released by all companies?
  2. Will an album always have a catelog code?
**** C
+ Question:
  To speed up queries, which columns are good candidates for indexes?
+ Answer:
  Primary key columns get indexes by default, but we should add an index to the album_id foreign key column in the songs table because we'll use it in table joins.
  It's likely that we'll query these tables to search by titles and artists, so those columns in both tables should get indexes too.
  The release_date in albums also is a candidate if we expect to perform many queries that include date ranges.
** Chapter 20 -
*** 
*** PRACTICE
**** Setup
Here we create the tables required for this exercise:
#+NAME: chapter-8-P0
#+HEADER: :engine postgres
#+HEADER: :dbhost localhost
#+HEADER: :dbuser sebastian
#+HEADER: :database analysis
#+begin_src sql
  CREATE TABLE albums (
      album_id bigint GENERATED ALWAYS AS IDENTITY,
      catalog_code text,
      title text,
      artist text,
      release_date date,
      genre text,
      description text
  );

  CREATE TABLE songs (
      song_id bigint GENERATED ALWAYS AS IDENTITY,
      title text,
      composers text,
      album_id bigint
  );  
#+end_src
**** A
+ Question:
  Modify these CREATE TABLE statements to include primary and foreign keys plus additional constraints on both tables.
  Explain why you made your choices.
+ Answer:
  * Both tables get a primary key using surrogate key id values that are auto-generated via IDENTITY.
  * The songs table references albums via a foreign key constraint.
  * In both tables, the title and artist/composer columns cannot be empty, which is specified via a NOT NULL constraint.
    We assume that every album and song should at minimum have that information.
  * In albums, the release_date column has a CHECK constraint because it would be likely impossible for us to own an LP made before 1925.
#+NAME: chapter-8-P1
#+HEADER: :engine postgres
#+HEADER: :dbhost localhost
#+HEADER: :dbuser sebastian
#+HEADER: :database analysis
#+begin_src sql
  CREATE TABLE albums (
      album_id bigint GENERATED ALWAYS AS IDENTITY,
      catalog_code text NOT NULL,
      title text NOT NULL,
      artist text NOT NULL,
      release_date date,
      genre text,
      description text,
      CONSTRAINT album_id_key PRIMARY KEY (album_id),
      CONSTRAINT release_date_check CHECK (release_date > '1/1/1925')
  );

  CREATE TABLE songs (
      song_id bigint GENERATED ALWAYS AS IDENTITY,
      title text NOT NULL,
      composers text NOT NULL,
      album_id bigint REFERENCES albums (album_id)
      CONSTRAINT song_id_key PRIMARY KEY (song_id)
  );  
#+end_src
**** B
+ Question:
  Instead of using =album_id= as a surrogate key for your ~primary key~, are there any columns in albums that could be useful as a natural key?
  What would you have to know to decide?
+ Answer:
  We could consider the catalog_code. We would have to answer yes to these questions:
  1. Is it going to be unique across all albums released by all companies?
  2. Will an album always have a catelog code?
**** C
+ Question:
  To speed up queries, which columns are good candidates for indexes?
+ Answer:
  Primary key columns get indexes by default, but we should add an index to the album_id foreign key column in the songs table because we'll use it in table joins.
  It's likely that we'll query these tables to search by titles and artists, so those columns in both tables should get indexes too.
  The release_date in albums also is a candidate if we expect to perform many queries that include date ranges.
